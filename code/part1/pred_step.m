function [covarEst,uEst] = pred_step(uPrev,covarPrev,angVel,acc,dt)
%covarPrev and uPrev are the previous mean and covariance respectively
%angVel is the angular velocity
%acc is the acceleration
%dt is the sampling time
%% G matrix inverse calculation (Omega = G*(q_dot))

% Omega is in body frame in my calculations so no need to multiply with R
angle_x=uPrev(4,1);
angle_y=uPrev(5,1);
angle_z=uPrev(6,1);

%G=[1 0 -sin(angle_y);0 cos(angle_x) sin(angle_x)*cos(angle_y);0 -sin(angle_x) cos(angle_x)*cos(angle_y)];
%simplify(inv(G))
%%precomputing Ginv
Ginv=[1, (sin(angle_x)*sin(angle_y))/cos(angle_y), (cos(angle_x)*sin(angle_y))/cos(angle_y);0, cos(angle_x), -sin(angle_x);0, sin(angle_x)/cos(angle_y), cos(angle_x)/cos(angle_y)];

%% R matrix calculation
%eul=[angle_z angle_y angle_x]; %eul2rotm needs it in ZYX order
%R=eul2rotm(eul,'ZYX');
%Precomputing R = Rz*Ry*Rx
R=[cos(angle_y)*cos(angle_z), cos(angle_z)*sin(angle_x)*sin(angle_y) - cos(angle_x)*sin(angle_z), sin(angle_x)*sin(angle_z) + cos(angle_x)*cos(angle_z)*sin(angle_y); cos(angle_y)*sin(angle_z), cos(angle_x)*cos(angle_z) + sin(angle_x)*sin(angle_y)*sin(angle_z), cos(angle_x)*sin(angle_y)*sin(angle_z) - cos(angle_z)*sin(angle_x); -sin(angle_y), cos(angle_y)*sin(angle_x), cos(angle_x)*cos(angle_y)];

%% Process model (values are subbed in)
% Substitute u(t-1) and input values in f(u(t-1),input,0)

g=[0;0;-9.81]; %m/s
q_dot=Ginv*(angVel-uPrev(10:12,1));
body_acc=g+R*(acc-uPrev(13:15,1));

state_dot=vertcat(uPrev(7:9,1),q_dot,body_acc,zeros(6,1)); %x_dot

%% Pre computing jacobians symbolic matrix and substituting (for efficiency)

%The commented code below can be used to find symbolic At and Ut I have run
%that code and pasted the command line At and Ut matrices so into SymAt and

%Then I substitute the required values

% Ginv=[1, (sin(anglex)*sin(angley))/cos(angley), (cos(anglex)*sin(angley))/cos(angley);0, cos(anglex), -sin(anglex);0, sin(anglex)/cos(angley), cos(anglex)/cos(angley)];
% Rz=[cos(anglez) -sin(anglez) 0;sin(anglez) cos(anglez) 0;0 0 1];
% Ry=[cos(angley) 0 sin(angley);0 1 0;-sin(angley) 0 cos(angley)];
% Rx=[1 0 0;0 cos(anglex) -sin(anglex);0 sin(anglex) cos(anglex)];
% R=Rz*Ry*Rx
% x3=[vx;vy;vz]
% x4=[bg1;bg2;bg3]
% x5=[ba1;ba2;ba3]
% X=[x; y; z; anglex; angley; anglez; vx; vy; vz; bg1; bg2; bg3; ba1; ba2; ba3]
% U=[W1; W2; W3; A1; A2; A3];
% N=[nv1; nv2; nv3; ng1; ng2; ng3; na1; na2; na3; nbg1; nbg2; nbg3; nba1; nba2; nba3]
% g=[0;0;-9.81]
% ng=[ng1;ng2;ng3];
% na=[na1;na2;na3];
% nbg=[nbg1;nbg2;nbg3];
% nba=[nba1;nba2;nba3]
% W=[W1;W2;W3]
% A=[A1;A2;A3]
% f=vertcat(x3,Ginv*(W-x4-ng),g+R*(A-x5-na),nbg,nba)
% At=jacobian(f,X)
% % Bt=jacobian(f,u)
% Ut=jacobian(f,N)

% using matlabFunction with the precomputed symbolic jacobian matrix

persistent SymAt SymUt %sub values into these to find jacobians
if isempty(SymAt)
    syms x y z anglex angley anglez vx vy vz bg1 bg2 bg3 ba1 ba2 ba3 nv1 nv2 nv3 ng1 ng2 ng3 na1 na2 na3 nbg1 nbg2 nbg3 nba1 nba2 nba3 W1 W2 W3 A1 A2 A3
    jacobAt(x, y, z, anglex, angley, anglez, vx, vy, vz, bg1, bg2, bg3, ba1, ba2, ba3, nv1, nv2, nv3, ng1, ng2, ng3, na1, na2, na3, nbg1, nbg2, nbg3, nba1, nba2, nba3, W1, W2, W3, A1, A2,A3)=simplify([0, 0, 0,  0,                                                                                                                                                                                       0,                                                                                                                                                                                                              0, 1, 0, 0,  0,                                      0,                                      0,                        0,                                                               0,                                                               0; 0, 0, 0,                                                                                                                                                                     0,                                                                                                                                                                                       0,                                                                                                                                                                                                              0, 0, 1, 0,  0,                                      0,                                      0,                        0,                                                               0,                                                               0; 0, 0, 0,                                                                                                                                                                     0,                                                                                                                                                                                       0,                                                                                                                                                                                                              0, 0, 0, 1,  0,                                      0,                                      0,                        0,                                                               0,                                                               0; 0, 0, 0,                                                       (sin(anglex)*sin(angley)*(bg3 - W3 + ng3))/cos(angley) - (cos(anglex)*sin(angley)*(bg2 - W2 + ng2))/cos(angley), - cos(anglex)*(bg3 - W3 + ng3) - sin(anglex)*(bg2 - W2 + ng2) - (cos(anglex)*sin(angley)^2*(bg3 - W3 + ng3))/cos(angley)^2 - (sin(anglex)*sin(angley)^2*(bg2 - W2 + ng2))/cos(angley)^2,                                                                                                                                                                                                              0, 0, 0, 0, -1, -(sin(anglex)*sin(angley))/cos(angley), -(cos(anglex)*sin(angley))/cos(angley),                        0,                                                               0,                                                               0; 0, 0, 0,                                                                                                           cos(anglex)*(bg3 - W3 + ng3) + sin(anglex)*(bg2 - W2 + ng2),                                                                                                                                                                                       0,                                                                                                                                                                                                              0, 0, 0, 0,  0,                           -cos(anglex),                            sin(anglex),                        0,                                                               0,                                                               0; 0, 0, 0,                                                                               (sin(anglex)*(bg3 - W3 + ng3))/cos(angley) - (cos(anglex)*(bg2 - W2 + ng2))/cos(angley),                                                                   - (cos(anglex)*sin(angley)*(bg3 - W3 + ng3))/cos(angley)^2 - (sin(anglex)*sin(angley)*(bg2 - W2 + ng2))/cos(angley)^2,                                                                                                                                                                                                              0, 0, 0, 0,  0,               -sin(anglex)/cos(angley),               -cos(anglex)/cos(angley),                        0,                                                               0,                                                               0; 0, 0, 0, - (sin(anglex)*sin(anglez) + cos(anglex)*cos(anglez)*sin(angley))*(ba2 - A2 + na2) - (cos(anglex)*sin(anglez) - cos(anglez)*sin(anglex)*sin(angley))*(ba3 - A3 + na3),                                  cos(anglez)*sin(angley)*(ba1 - A1 + na1) - cos(anglex)*cos(angley)*cos(anglez)*(ba3 - A3 + na3) - cos(angley)*cos(anglez)*sin(anglex)*(ba2 - A2 + na2), (cos(anglex)*cos(anglez) + sin(anglex)*sin(angley)*sin(anglez))*(ba2 - A2 + na2) - (cos(anglez)*sin(anglex) - cos(anglex)*sin(angley)*sin(anglez))*(ba3 - A3 + na3) + cos(angley)*sin(anglez)*(ba1 - A1 + na1), 0, 0, 0,  0,                                      0,                                      0, -cos(angley)*cos(anglez),   cos(anglex)*sin(anglez) - cos(anglez)*sin(anglex)*sin(angley), - sin(anglex)*sin(anglez) - cos(anglex)*cos(anglez)*sin(angley); 0, 0, 0,   (cos(anglez)*sin(anglex) - cos(anglex)*sin(angley)*sin(anglez))*(ba2 - A2 + na2) + (cos(anglex)*cos(anglez) + sin(anglex)*sin(angley)*sin(anglez))*(ba3 - A3 + na3),                                  sin(angley)*sin(anglez)*(ba1 - A1 + na1) - cos(anglex)*cos(angley)*sin(anglez)*(ba3 - A3 + na3) - cos(angley)*sin(anglex)*sin(anglez)*(ba2 - A2 + na2), (cos(anglex)*sin(anglez) - cos(anglez)*sin(anglex)*sin(angley))*(ba2 - A2 + na2) - (sin(anglex)*sin(anglez) + cos(anglex)*cos(anglez)*sin(angley))*(ba3 - A3 + na3) - cos(angley)*cos(anglez)*(ba1 - A1 + na1), 0, 0, 0,  0,                                      0,                                      0, -cos(angley)*sin(anglez), - cos(anglex)*cos(anglez) - sin(anglex)*sin(angley)*sin(anglez),   cos(anglez)*sin(anglex) - cos(anglex)*sin(angley)*sin(anglez); 0, 0, 0,                                                                                   cos(angley)*sin(anglex)*(ba3 - A3 + na3) - cos(anglex)*cos(angley)*(ba2 - A2 + na2),                                                                      cos(angley)*(ba1 - A1 + na1) + cos(anglex)*sin(angley)*(ba3 - A3 + na3) + sin(anglex)*sin(angley)*(ba2 - A2 + na2),                                                                                                                                                                                                              0, 0, 0, 0,  0,                                      0,                                      0,              sin(angley),                                        -cos(angley)*sin(anglex),                                        -cos(anglex)*cos(angley); 0, 0, 0,                                                                                                                                                                     0,                                                                                                                                                                                       0,                                                                                                                                                                                                              0, 0, 0, 0,  0,                                      0,                                      0,                        0,                                                               0,                                                               0; 0, 0, 0,                                                                                                                                                                     0,                                                                                                                                                                                       0,                                                                                                                                                                                                              0, 0, 0, 0,  0,                                      0,                                      0,                        0,                                                               0,                                                               0; 0, 0, 0,                                                                                                                                                                     0,                                                                                                                                                                                       0,                                                                                                                                                                                                              0, 0, 0, 0,  0,                                      0,                                      0,                        0,                                                               0,                                                               0; 0, 0, 0,                                                                                                                                                                     0,                                                                                                                                                                                       0,                                                                                                                                                                                                              0, 0, 0, 0,  0,                                      0,                                      0,                        0,                                                               0,                                                               0; 0, 0, 0,                                                                                                                                                                     0,                                                                                                                                                                                       0,                                                                                                                                                                                                              0, 0, 0, 0,  0,                                      0,                                      0,                        0,                                                               0,                                                               0; 0, 0, 0,                                                                                                                                                                     0,                                                                                                                                                                                       0,                                                                                                                                                                                                              0, 0, 0, 0,  0,                                      0,                                      0,                        0,                                                               0,                                                               0]);
    SymAt=matlabFunction(jacobAt);
    % Can make cleaner by using vertcat()
    jacobUt(x, y, z, anglex, angley, anglez, vx, vy, vz, bg1, bg2, bg3, ba1, ba2, ba3, nv1, nv2, nv3, ng1, ng2, ng3, na1, na2, na3, nbg1, nbg2, nbg3, nba1, nba2, nba3, W1, W2, W3, A1, A2,A3)= simplify([0, 0, 0,  0,                                      0,                                      0,                        0,                                                               0,                                                               0, 0, 0, 0, 0, 0, 0; 0, 0, 0,  0,                                      0,                                      0,                        0,                                                               0,                                                               0, 0, 0, 0, 0, 0, 0; 0, 0, 0,  0,                                      0,                                      0,                        0,                                                               0,                                                               0, 0, 0, 0, 0, 0, 0; 0, 0, 0, -1, -(sin(anglex)*sin(angley))/cos(angley), -(cos(anglex)*sin(angley))/cos(angley),                        0,                                                               0,                                                               0, 0, 0, 0, 0, 0, 0; 0, 0, 0,  0,                           -cos(anglex),                            sin(anglex),                        0,                                                               0,                                                               0, 0, 0, 0, 0, 0, 0; 0, 0, 0,  0,               -sin(anglex)/cos(angley),               -cos(anglex)/cos(angley),                        0,                                                               0,                                                               0, 0, 0, 0, 0, 0, 0; 0, 0, 0,  0,                                      0,                                      0, -cos(angley)*cos(anglez),   cos(anglex)*sin(anglez) - cos(anglez)*sin(anglex)*sin(angley), - sin(anglex)*sin(anglez) - cos(anglex)*cos(anglez)*sin(angley), 0, 0, 0, 0, 0, 0; 0, 0, 0,  0,                                      0,                                      0, -cos(angley)*sin(anglez), - cos(anglex)*cos(anglez) - sin(anglex)*sin(angley)*sin(anglez),   cos(anglez)*sin(anglex) - cos(anglex)*sin(angley)*sin(anglez), 0, 0, 0, 0, 0, 0; 0, 0, 0,  0,                                      0,                                      0,              sin(angley),                                        -cos(angley)*sin(anglex),                                        -cos(anglex)*cos(angley), 0, 0, 0, 0, 0, 0; 0, 0, 0,  0,                                      0,                                      0,                        0,                                                               0,                                                               0, 1, 0, 0, 0, 0, 0; 0, 0, 0,  0,                                      0,                                      0,                        0,                                                               0,                                                               0, 0, 1, 0, 0, 0, 0; 0, 0, 0,  0,                                      0,                                      0,                        0,                                                               0,                                                               0, 0, 0, 1, 0, 0, 0; 0, 0, 0,  0,                                      0,                                      0,                        0,                                                               0,                                                               0, 0, 0, 0, 1, 0, 0; 0, 0, 0,  0,                                      0,                                      0,                        0,                                                               0,                                                               0, 0, 0, 0, 0, 1, 0; 0, 0, 0,  0,                                      0,                                      0,                        0,                                                               0,                                                               0, 0, 0, 0, 0, 0, 1]);
    SymUt=matlabFunction(jacobUt);
end
% substitutions in At and Ut
%sub_vals=horzcat(transpose(uPrev),zeros(1,15),transpose(angVel),transpose(acc)); 

%% At Ut and Ft calculation

At=SymAt(uPrev(1,1),uPrev(2,1),uPrev(3,1),uPrev(4,1),uPrev(5,1),uPrev(6,1),uPrev(7,1),uPrev(8,1),uPrev(9,1),uPrev(10,1),uPrev(11,1),uPrev(12,1),uPrev(13,1),uPrev(14,1),uPrev(15,1),0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,angVel(1,1),angVel(2,1),angVel(3,1),acc(1,1),acc(2,1),acc(3,1));
%Ut = Vt so im not wasting memory copying it

Ut=SymUt(uPrev(1,1),uPrev(2,1),uPrev(3,1),uPrev(4,1),uPrev(5,1),uPrev(6,1),uPrev(7,1),uPrev(8,1),uPrev(9,1),uPrev(10,1),uPrev(11,1),uPrev(12,1),uPrev(13,1),uPrev(14,1),uPrev(15,1),0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,angVel(1,1),angVel(2,1),angVel(3,1),acc(1,1),acc(2,1),acc(3,1));

Ft=eye(15)+dt*At; %Ft calculation

%% Qd calculation
persistent Q
if isempty(Q) %Everytime you run the code the Qd matrix changes but stays constant through iterations
    Q_values=rand(15,1); %Randomize Q covariance matrix elements so that all the diagonal terms are different
    
    %Q_values=[1,2,3,2,3,4,3,2,1,2,3,1,2,3,1]%change this value and test (noise variance)
    Q=diag(Q_values); %diagonal matrix 
end
Qd=dt*Q; %Can be dt*eye(15) as well


%% Pred_step outputs
uEst=uPrev+dt*state_dot;
covarEst=Ft*covarPrev*transpose(Ft)+Ut*Qd*transpose(Ut);
end

